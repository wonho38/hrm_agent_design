<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HRM AI Agent</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 30px;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e9ecef;
        }

        .title {
            font-size: 2.5rem;
            font-weight: bold;
            color: #2c3e50;
            text-align: center;
            flex-grow: 1;
        }

        .settings {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .setting-group {
            display: flex;
            flex-direction: row;
            gap: 10px;
            align-items: center;
        }

        .setting-label {
            font-weight: 600;
            color: #495057;
            font-size: 0.9rem;
        }

        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 30px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 8px;
        }

        .control-group {
            display: flex;
            flex-direction: row;
            gap: 10px;
            align-items: center;
        }

        .control-label {
            font-weight: 600;
            color: #495057;
            font-size: 0.9rem;
        }

        select {
            padding: 8px 12px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            font-size: 14px;
            background-color: white;
            cursor: pointer;
            transition: border-color 0.3s ease;
        }

        select:hover {
            border-color: #007bff;
        }

        select:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
        }

        .generate-btn {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin-left: 20px;
        }

        .generate-btn:hover {
            background-color: #0056b3;
        }

        .generate-btn:active {
            transform: translateY(1px);
        }

        .content-area {
            display: flex;
            flex-direction: column;
            gap: 30px;
            margin-top: 20px;
        }

        .top-textboxes {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
        }

        .bottom-textboxes {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .textbox-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: stretch;
            position: relative; /* 컨테이너 위치 고정 */
        }

        .textbox-label {
            font-weight: 600;
            color: #495057;
            font-size: 1rem;
        }

        textarea {
            width: 100%;
            height: 400px;
            padding: 15px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            resize: vertical;
            background-color: #fafafa;
            transition: border-color 0.3s ease;
        }

        textarea:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
            background-color: white;
        }

        .readonly {
            background-color: #f8f9fa;
            color: #6c757d;
        }

        .loading {
            opacity: 0.6;
            pointer-events: none;
        }

        .error {
            color: #dc3545;
            font-size: 0.9rem;
            margin-top: 5px;
        }

        .spinner {
            display: none;
            width: 20px;
            height: 20px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }

        .status-message {
            display: none;
            margin-left: 15px;
            color: #28a745;
            font-size: 0.9rem;
            font-weight: 600;
            padding: 8px 12px;
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            border: 1px solid #28a745;
            border-radius: 20px;
            animation: statusPulse 1.5s ease-in-out infinite;
            box-shadow: 0 2px 4px rgba(40, 167, 69, 0.2);
            align-items: center;
            gap: 8px;
        }

        .status-message.active {
            display: flex;
        }

        .status-message::before {
            content: '';
            width: 12px;
            height: 12px;
            border: 2px solid #28a745;
            border-top: 2px solid transparent;
            border-radius: 50%;
            animation: statusSpin 1s linear infinite;
        }

        @keyframes statusPulse {
            0%, 100% { 
                opacity: 1; 
                transform: scale(1);
                box-shadow: 0 2px 4px rgba(40, 167, 69, 0.2);
            }
            50% { 
                opacity: 0.8; 
                transform: scale(1.02);
                box-shadow: 0 4px 8px rgba(40, 167, 69, 0.3);
            }
        }

        @keyframes statusSpin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .button-container {
            display: flex;
            align-items: center;
        }

        /* Header navigation links */
        .nav-links {
            display: flex;
            gap: 12px;
            align-items: center;
        }
        .nav-link {
            color: #007bff;
            text-decoration: none;
            font-weight: 600;
            padding: 6px 10px;
            border-radius: 4px;
            transition: background-color 0.2s ease;
        }
        .nav-link:hover {
            background-color: #e7f3ff;
        }

        /* Formatted operation history styles */
        .formatted-op-history {
            line-height: 1.6;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #fafafa;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            min-height: 400px;
            transition: all 0.3s ease;
        }

        .formatted-op-history:hover {
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
            background-color: white;
        }

        .op-history-title {
            color: #2c3e50;
            margin: 0 0 15px 0;
            font-size: 1.2em;
            font-weight: 600;
            border-bottom: 2px solid #3498db;
            padding-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .op-history-list {
            margin: 0;
            padding: 0;
            list-style: none;
        }

        .op-history-item {
            margin: 12px 0;
            padding: 12px 15px;
            border-radius: 6px;
            position: relative;
            border-left: 4px solid #3498db;
            background: #f8f9fa;
            transition: all 0.2s ease;
        }

        .op-history-item:hover {
            background: #e9ecef;
            transform: translateX(2px);
        }

        .op-history-item.conclusion {
            background: #d4edda;
            border-left-color: #28a745;
        }

        .op-history-item.warning {
            background: #fff3cd;
            border-left-color: #ffc107;
        }

        .op-history-item.error {
            background: #f8d7da;
            border-left-color: #dc3545;
        }

        .op-history-item.info {
            background: #d1ecf1;
            border-left-color: #17a2b8;
        }

        .op-history-icon {
            display: inline-block;
            margin-right: 8px;
            font-weight: bold;
            font-size: 1.1em;
        }

        .op-history-text {
            display: inline;
        }

        .op-history-text strong {
            color: #2c3e50;
            font-weight: 600;
        }

        .op-history-text em {
            color: #6c757d;
            font-style: normal;
            background: #e9ecef;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .format-toggle-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
            opacity: 0.8;
            transition: opacity 0.3s ease;
            z-index: 10;
        }

        .format-toggle-btn:hover {
            opacity: 1;
        }

        /* Formatted user guide styles */
        .formatted-user-guide {
            line-height: 1.6;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #fafafa;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            min-height: 200px;
            transition: all 0.3s ease;
        }
        .formatted-user-guide:hover {
            border-color: #6f42c1;
            box-shadow: 0 0 0 3px rgba(111, 66, 193, 0.1);
            background-color: white;
        }
        .user-guide-title {
            color: #2c3e50;
            margin: 0 0 15px 0;
            font-size: 1.2em;
            font-weight: 600;
            border-bottom: 2px solid #6f42c1;
            padding-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .user-guide-list { margin: 0; padding-left: 18px; }
        .user-guide-item { margin: 10px 0; }
        .user-guide-source a { color: #6f42c1; text-decoration: none; }
        .user-guide-source a:hover { text-decoration: underline; }

        /* Formatted diagnosis styles - 새로운 박스 형태 */
        .formatted-diagnosis {
            line-height: 1.6;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #fafafa;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            min-height: 400px;
            transition: all 0.3s ease;
        }

        .formatted-diagnosis:hover {
            border-color: #28a745;
            box-shadow: 0 0 0 3px rgba(40, 167, 69, 0.1);
            background-color: white;
        }

        .diagnosis-title {
            color: #2c3e50;
            margin: 0 0 20px 0;
            font-size: 1.3em;
            font-weight: 600;
            border-bottom: 2px solid #28a745;
            padding-bottom: 10px;
            text-align: center;
        }

        /* 결론 스타일 */
        .diagnosis-conclusion {
            background: linear-gradient(135deg, #e8f5e8 0%, #d4edda 100%);
            border: 1px solid #c3e6cb;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .diagnosis-conclusion-label {
            font-weight: 700;
            font-size: 1.1em;
            color: #155724;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .diagnosis-conclusion-content {
            color: #155724;
            font-size: 1em;
            line-height: 1.5;
        }

        /* 진단 항목들 컨테이너 */
        .diagnosis-items {
            display: grid;
            gap: 12px;
            margin-bottom: 15px;
        }

        /* 개별 진단 항목 */
        .diagnosis-item {
            display: flex;
            align-items: flex-start;
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            border-left: 4px solid #28a745;
            transition: all 0.2s ease;
        }

        .diagnosis-item:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transform: translateX(2px);
        }

        .diagnosis-item.normal {
            border-left-color: #28a745;
            background: linear-gradient(135deg, #f8fff8 0%, #f0f8f0 100%);
        }

        .diagnosis-item.abnormal {
            border-left-color: #dc3545;
            background: linear-gradient(135deg, #fff8f8 0%, #f8f0f0 100%);
        }

        .diagnosis-item.warning {
            border-left-color: #ffc107;
            background: linear-gradient(135deg, #fffef8 0%, #faf8f0 100%);
        }

        .diagnosis-item.info {
            border-left-color: #17a2b8;
            background: linear-gradient(135deg, #f8feff 0%, #f0f8fa 100%);
        }

        .diagnosis-item.recommendation {
            border-left-color: #6f42c1;
            background: linear-gradient(135deg, #faf8ff 0%, #f5f0ff 100%);
        }

        /* 진단 항목 번호 */
        .diagnosis-item-number {
            background: #28a745;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 1.1em;
            margin-right: 15px;
            flex-shrink: 0;
        }

        .diagnosis-item.abnormal .diagnosis-item-number {
            background: #dc3545;
        }

        .diagnosis-item.warning .diagnosis-item-number {
            background: #ffc107;
            color: #212529;
        }

        .diagnosis-item.info .diagnosis-item-number {
            background: #17a2b8;
        }

        .diagnosis-item.recommendation .diagnosis-item-number {
            background: #6f42c1;
        }

        /* 진단 항목 내용 */
        .diagnosis-item-content {
            flex: 1;
            color: #2c3e50;
            font-size: 0.95em;
            line-height: 1.5;
        }

        /* 진단 메인 내용 */
        .diagnosis-main-content {
            margin-bottom: 8px;
        }

        /* 진단 하위 항목들 */
        .diagnosis-sub-items {
            margin: 8px 0 0 0;
            padding-left: 20px;
            list-style: none;
        }

        .diagnosis-sub-item {
            position: relative;
            margin: 4px 0;
            padding-left: 15px;
            color: #495057;
            font-size: 0.9em;
            line-height: 1.4;
        }

        .diagnosis-sub-item::before {
            content: "•";
            position: absolute;
            left: 0;
            top: 0;
            color: #6c757d;
            font-weight: bold;
        }

        .diagnosis-sub-item:hover {
            color: #2c3e50;
        }

        /* 기타 항목들 */
        .diagnosis-other-items {
            display: grid;
            gap: 10px;
        }

        .diagnosis-other-item {
            background: white;
            border-radius: 6px;
            padding: 12px 15px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            border-left: 3px solid #6c757d;
            transition: all 0.2s ease;
        }

        .diagnosis-other-item:hover {
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            transform: translateX(1px);
        }

        .diagnosis-other-item.normal {
            border-left-color: #28a745;
            background: linear-gradient(135deg, #f8fff8 0%, #f0f8f0 100%);
        }

        .diagnosis-other-item.abnormal {
            border-left-color: #dc3545;
            background: linear-gradient(135deg, #fff8f8 0%, #f8f0f0 100%);
        }

        .diagnosis-other-item.warning {
            border-left-color: #ffc107;
            background: linear-gradient(135deg, #fffef8 0%, #faf8f0 100%);
        }

        .diagnosis-other-item.info {
            border-left-color: #17a2b8;
            background: linear-gradient(135deg, #f8feff 0%, #f0f8fa 100%);
        }

        .diagnosis-other-item.recommendation {
            border-left-color: #6f42c1;
            background: linear-gradient(135deg, #faf8ff 0%, #f5f0ff 100%);
        }

        .diagnosis-other-content {
            color: #2c3e50;
            font-size: 0.9em;
            line-height: 1.4;
        }

        /* Readability Report Styles */
        .readability-section {
            margin-top: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 8px;
            border-left: 4px solid #007bff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            width: 100%;
            box-sizing: border-box;
            order: 10; /* 가독성 섹션을 가장 아래로 */
        }

        .readability-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #dee2e6;
        }

        .readability-title {
            font-size: 1.1em;
            font-weight: 600;
            color: #495057;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .readability-toggle {
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .readability-toggle:hover {
            background: #0056b3;
        }

        .readability-content {
            line-height: 1.6;
        }

        .readability-overall {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background: white;
            border-radius: 6px;
            font-weight: 600;
        }

        .readability-overall.good {
            background: #d4edda;
            color: #155724;
            border-left: 4px solid #28a745;
        }

        .readability-overall.poor {
            background: #f8d7da;
            color: #721c24;
            border-left: 4px solid #dc3545;
        }

        .readability-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .readability-metric {
            background: white;
            padding: 8px 12px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
        }

        .readability-metric .icon {
            font-size: 1.1em;
        }

        .readability-terms {
            background: white;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .readability-terms-title {
            font-weight: 600;
            color: #495057;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        .readability-terms-list {
            color: #6c757d;
            font-size: 0.85em;
            line-height: 1.4;
        }

        .readability-recommendations {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 4px;
            padding: 10px;
        }

        .readability-recommendations-title {
            font-weight: 600;
            color: #856404;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .readability-recommendations ul {
            margin: 0;
            padding-left: 20px;
            color: #856404;
        }

        .readability-recommendations li {
            margin-bottom: 4px;
            font-size: 0.9em;
        }

        .readability-collapsed {
            display: none;
        }

        @media (max-width: 768px) {
            .readability-metrics {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="nav-links">
                <a class="nav-link" href="/guide-retriever">Guide Retriever</a>
                <a class="nav-link" href="/data-review">Data Review</a>
                <a class="nav-link" href="/prompt-editor">Prompt Editor</a>
            </div>
            <h1 class="title">HRM AI Agent</h1>
            <div class="settings">
                <div class="setting-group">
                    <label class="setting-label">LLM:</label>
                    <select id="llmSelect">
                        <option value="aws">AWS</option>
                        <option value="openai">OpenAI</option>
                        <option value="gauss">Gauss</option>
                        <option value="gausso">Gausso</option>
                    </select>
                </div>
                <div class="setting-group">
                    <label class="setting-label">Language:</label>
                    <select id="languageSelect">
                        <option value="ko">한국어</option>
                        <option value="en">English</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <label class="control-label">Product:</label>
                <select id="productSelect">
                    <option value="airconditioner">Airconditioner</option>
                    <option value="refrigerator">Refrigerator</option>
                    <option value="washer">Washer</option>
                </select>
            </div>
            <div class="control-group">
                <label class="control-label">ID:</label>
                <select id="idSelect">
                    <option value="">Loading...</option>
                </select>
            </div>
            <div class="button-container">
                <button class="generate-btn" id="generateBtn" onclick="generateContent()">Generation</button>
                <div class="spinner" id="loadingSpinner"></div>
                <div class="status-message" id="statusMessage"></div>
            </div>
        </div>

        <div class="content-area">
            <div class="top-textboxes">
                <div class="textbox-group">
                    <label class="textbox-label">Diagnosis Summarization</label>
                    <textarea id="diagnosisSummarization" placeholder="AI가 생성한 진단 요약이 여기에 표시됩니다..."></textarea>
                </div>
                <div class="textbox-group">
                    <label class="textbox-label">Op. History Summarization</label>
                    <textarea id="opHistorySummarization" placeholder="AI가 생성한 운영 이력 요약이 여기에 표시됩니다..."></textarea>
                </div>
                <div class="textbox-group">
                    <label class="textbox-label">User Guide</label>
                    <textarea id="userGuide" placeholder="AI가 생성한 사용자 가이드가 여기에 표시됩니다..."></textarea>
                </div>
            </div>
            <div class="bottom-textboxes">
                <div class="textbox-group">
                    <label class="textbox-label">Diagnosis Lists</label>
                    <textarea id="diagnosisLists" class="readonly" readonly placeholder="선택된 제품의 진단 목록이 여기에 표시됩니다..."></textarea>
                </div>
                <div class="textbox-group">
                    <label class="textbox-label">Operation History</label>
                    <textarea id="operationHistory" class="readonly" readonly placeholder="선택된 제품의 운영 이력이 여기에 표시됩니다..."></textarea>
                </div>
            </div>
        </div>
    </div>

    <script>
        let jsonData = [];

        // JSON 데이터 로드
        async function loadJsonData() {
            try {
                const response = await fetch('/api/data');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                jsonData = await response.json();
                console.log('JSON data loaded:', jsonData.length, 'items');
                updateIdOptions();
            } catch (error) {
                console.error('Error loading JSON data:', error);
                document.getElementById('idSelect').innerHTML = '<option value="">Error loading data</option>';
            }
        }

        // ID 옵션 업데이트
        function updateIdOptions() {
            const productSelect = document.getElementById('productSelect');
            const idSelect = document.getElementById('idSelect');
            const selectedProduct = productSelect.value;
            
            // 선택된 제품에 해당하는 ID들 필터링
            const filteredData = jsonData.filter(item => {
                if (selectedProduct === 'airconditioner') {
                    return item.id.startsWith('airconditioner_');
                } else if (selectedProduct === 'refrigerator') {
                    return item.id.startsWith('refrigerator_');
                } else if (selectedProduct === 'washer') {
                    return item.id.startsWith('washer_');
                }
                return false;
            });

            // ID 옵션 생성
            idSelect.innerHTML = '';
            if (filteredData.length > 0) {
                filteredData.forEach(item => {
                    const option = document.createElement('option');
                    option.value = item.id;
                    option.textContent = item.id;
                    idSelect.appendChild(option);
                });
            } else {
                // 해당 제품 타입의 데이터가 없는 경우
                for (let i = 1; i <= 25; i++) {
                    const option = document.createElement('option');
                    const idNumber = String(i).padStart(3, '0');
                    option.value = `${selectedProduct}_${idNumber}`;
                    option.textContent = `${selectedProduct}_${idNumber}`;
                    idSelect.appendChild(option);
                }
            }
        }

        // 제품 변경 시 ID 옵션 업데이트
        document.getElementById('productSelect').addEventListener('change', updateIdOptions);

        // 진단 요약 후처리 함수 (아이콘 없는 박스 형태)
        function formatDiagnosisSummary(rawText) {
            if (!rawText || rawText.trim() === '') return '';
            
            let lines = rawText.split('\n').filter(line => line.trim() !== '');
            
            // 첫 번째 줄에서 언어 키워드 제거
            if (lines.length > 0) {
                let processedLines = [];
                
                for (let i = 0; i < lines.length; i++) {
                    let line = lines[i].trim();
                    
                    // 언어 키워드 패턴들
                    const languagePatterns = [
                        /^한국어[:：\s]*(.*)$/gi,
                        /^영어[:：\s]*(.*)$/gi,
                        /^English[:：\s]*(.*)$/gi,
                        /^Korean[:：\s]*(.*)$/gi,
                        /^한글[:：\s]*(.*)$/gi,
                        /^korean[:：\s]*(.*)$/gi,
                        /^english[:：\s]*(.*)$/gi,
                        /^(한국어|영어|English|Korean|한글|korean|english)[:：\-\s]+(.+)$/gi,
                        /^(한국어|영어|English|Korean|한글|korean|english)[:：\-\s]*$/gi
                    ];
                    
                    let cleanedLine = line;
                    let wasLanguageLine = false;
                    
                    for (const pattern of languagePatterns) {
                        const match = cleanedLine.match(pattern);
                        if (match) {
                            if (match[1] && match[1].trim()) {
                                cleanedLine = match[1].trim();
                            } else if (match[2] && match[2].trim()) {
                                cleanedLine = match[2].trim();
                            } else {
                                wasLanguageLine = true;
                                break;
                            }
                            break;
                        }
                    }
                    
                    if (!wasLanguageLine && cleanedLine && cleanedLine.length > 0) {
                        processedLines.push(cleanedLine);
                    }
                }
                
                lines = processedLines;
            }
            
            // 결론 부분과 번호가 있는 항목들 분리
            let conclusionLine = '';
            let numberedItems = [];
            let otherItems = [];
            
            for (let i = 0; i < lines.length; i++) {
                const trimmedLine = lines[i].trim();
                if (trimmedLine === '') continue;
                
                // 번호가 있는 줄 찾기 (1., 2., 3. 등)
                const numberedMatch = trimmedLine.match(/^(\d+)\.\s*(.+)/);
                if (numberedMatch) {
                    // 번호가 있는 항목 생성
                    const item = {
                        number: numberedMatch[1],
                        content: numberedMatch[2],
                        subItems: []
                    };
                    
                    // 다음 줄들에서 하이픈으로 시작하는 관련 내용 찾기
                    let j = i + 1;
                    while (j < lines.length) {
                        const nextLine = lines[j].trim();
                        if (nextLine === '') {
                            j++;
                            continue;
                        }
                        
                        // 하이픈으로 시작하는 줄이거나 들여쓰기된 줄
                        if (nextLine.match(/^[-–—•]\s*(.+)/) || nextLine.match(/^\s+[-–—•]\s*(.+)/) || 
                            (nextLine.match(/^\s{2,}(.+)/) && !nextLine.match(/^\d+\.\s/))) {
                            item.subItems.push(nextLine);
                            j++;
                        } else if (nextLine.match(/^\d+\.\s/)) {
                            // 다음 번호 항목을 만나면 중단
                            break;
                        } else {
                            // 일반 텍스트지만 번호 항목이 아니면 하위 항목으로 포함
                            item.subItems.push(nextLine);
                            j++;
                        }
                    }
                    
                    numberedItems.push(item);
                    i = j - 1; // 처리한 줄들 건너뛰기
                } else if (i === 0 && !numberedMatch) {
                    // 첫 번째 줄이 번호가 없으면 결론으로 처리
                    conclusionLine = trimmedLine;
                } else {
                    // 그 외 항목들 (번호 항목에 포함되지 않은 경우만)
                    let isPartOfNumberedItem = false;
                    
                    // 이미 번호 항목에 포함되었는지 확인
                    for (let item of numberedItems) {
                        if (item.subItems.includes(trimmedLine)) {
                            isPartOfNumberedItem = true;
                            break;
                        }
                    }
                    
                    if (!isPartOfNumberedItem) {
                        otherItems.push(trimmedLine);
                    }
                }
            }
            
            let result = `
                <div class="formatted-diagnosis">
                    <h3 class="diagnosis-title">
                        <span>진단 분석 결과</span>
                    </h3>
            `;
            
            // 결론 부분 표시
            if (conclusionLine) {
                const processedConclusion = processTextFormatting(conclusionLine);
                result += `
                    <div class="diagnosis-conclusion">
                        <div class="diagnosis-conclusion-label">결론</div>
                        <div class="diagnosis-conclusion-content">${processedConclusion}</div>
                    </div>
                `;
            }
            
            // 번호가 있는 항목들 표시
            if (numberedItems.length > 0) {
                result += `<div class="diagnosis-items">`;
                
                numberedItems.forEach(item => {
                    const processedContent = processTextFormatting(item.content);
                    let cssClass = getDiagnosisItemClass(item.content);
                    
                    // 하위 항목들 처리
                    let subItemsHtml = '';
                    if (item.subItems && item.subItems.length > 0) {
                        subItemsHtml = '<ul class="diagnosis-sub-items">';
                        item.subItems.forEach(subItem => {
                            const processedSubItem = processTextFormatting(subItem);
                            // 하이픈이나 불릿 포인트 제거하고 정리
                            const cleanSubItem = processedSubItem.replace(/^[-–—•]\s*/, '').replace(/^\s+[-–—•]\s*/, '').trim();
                            subItemsHtml += `<li class="diagnosis-sub-item">${cleanSubItem}</li>`;
                        });
                        subItemsHtml += '</ul>';
                    }
                    
                    result += `
                        <div class="diagnosis-item ${cssClass}">
                            <div class="diagnosis-item-number">${item.number}</div>
                            <div class="diagnosis-item-content">
                                <div class="diagnosis-main-content">${processedContent}</div>
                                ${subItemsHtml}
                            </div>
                        </div>
                    `;
                });
                
                result += `</div>`;
            }
            
            // 기타 항목들 표시
            if (otherItems.length > 0) {
                result += `<div class="diagnosis-other-items">`;
                
                otherItems.forEach(item => {
                    const processedContent = processTextFormatting(item);
                    let cssClass = getDiagnosisItemClass(item);
                    
                    result += `
                        <div class="diagnosis-other-item ${cssClass}">
                            <div class="diagnosis-other-content">${processedContent}</div>
                        </div>
                    `;
                });
                
                result += `</div>`;
            }
            
            result += `</div>`;
            
            return result;
        }
        
        // 진단 항목의 CSS 클래스 결정 (키워드 기반)
        function getDiagnosisItemClass(content) {
            const lowerContent = content.toLowerCase();
            
            if (lowerContent.includes('정상') || lowerContent.includes('normal') || 
                lowerContent.includes('양호') || lowerContent.includes('good') ||
                lowerContent.includes('문제없음') || lowerContent.includes('정상 동작')) {
                return 'normal';
            } else if (lowerContent.includes('이상') || lowerContent.includes('abnormal') || 
                      lowerContent.includes('문제') || lowerContent.includes('오류') || 
                      lowerContent.includes('error') || lowerContent.includes('fault') ||
                      lowerContent.includes('고장') || lowerContent.includes('불량')) {
                return 'abnormal';
            } else if (lowerContent.includes('권장') || lowerContent.includes('recommend') || 
                      lowerContent.includes('조치') || lowerContent.includes('action') ||
                      lowerContent.includes('개선') || lowerContent.includes('improve') ||
                      lowerContent.includes('교체') || lowerContent.includes('청소') ||
                      lowerContent.includes('점검') || lowerContent.includes('확인')) {
                return 'recommendation';
            } else if (lowerContent.includes('주의') || lowerContent.includes('warning') || 
                      lowerContent.includes('경고') || lowerContent.includes('alert') ||
                      lowerContent.includes('위험') || lowerContent.includes('risk')) {
                return 'warning';
            } else {
                return 'info';
            }
        }

        // 진단 포맷팅 적용 함수
        function applyDiagnosisFormatting(textarea) {
            const rawText = textarea.value;
            if (!rawText || rawText.trim() === '') return;
            
            const parent = textarea.parentNode;
            
            // 기존 포맷된 요소들 제거 (가독성 섹션은 유지)
            const existingFormatted = parent.querySelector('.formatted-diagnosis');
            const existingToggle = parent.querySelector('.format-toggle-btn');
            if (existingFormatted) existingFormatted.remove();
            if (existingToggle) existingToggle.remove();
            
            // 포맷된 div 생성
            const formattedDiv = document.createElement('div');
            formattedDiv.innerHTML = formatDiagnosisSummary(rawText);
            
            // 토글 버튼 생성
            const toggleButton = document.createElement('button');
            toggleButton.className = 'format-toggle-btn';
            toggleButton.textContent = '원본';
            toggleButton.title = '원본 텍스트 보기/숨기기';
            
            // 가독성 섹션이 있는지 확인
            const readabilitySection = parent.querySelector('.readability-section');
            
            // textarea 숨기고 포맷된 div와 버튼 추가
            textarea.style.display = 'none';
            
            // 가독성 섹션이 있으면 그 앞에 추가, 없으면 맨 뒤에 추가
            if (readabilitySection) {
                parent.insertBefore(formattedDiv, readabilitySection);
                parent.insertBefore(toggleButton, readabilitySection);
            } else {
                parent.appendChild(formattedDiv);
                parent.appendChild(toggleButton);
            }
            
            // 토글 기능
            let showingFormatted = true;
            function toggleDisplay() {
                if (showingFormatted) {
                    textarea.style.display = 'block';
                    formattedDiv.style.display = 'none';
                    toggleButton.textContent = '포맷';
                    toggleButton.title = '포맷된 보기로 전환';
                    showingFormatted = false;
                } else {
                    textarea.style.display = 'none';
                    formattedDiv.style.display = 'block';
                    toggleButton.textContent = '원본';
                    toggleButton.title = '원본 텍스트 보기로 전환';
                    showingFormatted = true;
                }
            }
            
            toggleButton.addEventListener('click', toggleDisplay);
            formattedDiv.addEventListener('dblclick', toggleDisplay);
            
            const formattedContent = formattedDiv.querySelector('.formatted-diagnosis');
            if (formattedContent) {
                formattedContent.title = '더블클릭하면 원본 텍스트를 볼 수 있습니다';
            }
        }

        // 운영 이력 요약 후처리 함수
        function formatOperationHistorySummary(rawText) {
            if (!rawText || rawText.trim() === '') return '';
            
            // HTML 엔티티 이스케이프
            function escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
            
            let lines = rawText.split('\n').filter(line => line.trim() !== '');
            
            // 첫 번째 줄에서 언어 키워드 제거 (강화된 버전)
            if (lines.length > 0) {
                let processedLines = [];
                
                for (let i = 0; i < lines.length; i++) {
                    let line = lines[i].trim();
                    
                    // 언어 키워드 패턴들 (더 포괄적)
                    const languagePatterns = [
                        /^한국어[:：\s]*(.*)$/gi,
                        /^영어[:：\s]*(.*)$/gi,
                        /^English[:：\s]*(.*)$/gi,
                        /^Korean[:：\s]*(.*)$/gi,
                        /^한글[:：\s]*(.*)$/gi,
                        /^korean[:：\s]*(.*)$/gi,
                        /^english[:：\s]*(.*)$/gi,
                        // 줄 시작 부분의 언어 키워드
                        /^(한국어|영어|English|Korean|한글|korean|english)[:：\-\s]+(.+)$/gi,
                        // 줄 전체가 언어 키워드인 경우
                        /^(한국어|영어|English|Korean|한글|korean|english)[:：\-\s]*$/gi
                    ];
                    
                    let cleanedLine = line;
                    let wasLanguageLine = false;
                    
                    // 각 패턴을 확인하여 언어 키워드 제거
                    for (const pattern of languagePatterns) {
                        const match = cleanedLine.match(pattern);
                        if (match) {
                            if (match[1] && match[1].trim()) {
                                // 언어 키워드 뒤에 내용이 있으면 그 내용만 유지
                                cleanedLine = match[1].trim();
                            } else if (match[2] && match[2].trim()) {
                                // 두 번째 캡처 그룹에 내용이 있으면 그것을 사용
                                cleanedLine = match[2].trim();
                            } else {
                                // 언어 키워드만 있고 내용이 없으면 이 줄을 건너뜀
                                wasLanguageLine = true;
                                break;
                            }
                            break;
                        }
                    }
                    
                    // 유효한 내용이 있는 줄만 추가
                    if (!wasLanguageLine && cleanedLine && cleanedLine.length > 0) {
                        processedLines.push(cleanedLine);
                    }
                }
                
                lines = processedLines;
            }
            
            let result = `
                <div class="formatted-op-history">
                    <h3 class="op-history-title">
                        <span>🔍</span>
                        <span>운영 이력 분석 결과</span>
                        <span style="margin-left: auto; font-size: 0.8em; color: #6c757d;">📈</span>
                    </h3>
                    <ul class="op-history-list">
            `;
            
            lines.forEach((line, index) => {
                const trimmedLine = line.trim();
                if (trimmedLine === '') return;
                
                let cssClass = '';
                let icon = '▶';
                let processedLine = trimmedLine;
                
                // 번호가 있는 줄 처리 (1., 2., 3. 등)
                const numberedMatch = processedLine.match(/^(\d+)\.\s*(.+)/);
                if (numberedMatch) {
                    processedLine = numberedMatch[2];
                    
                    // 첫 번째 항목은 보통 결론
                    if (numberedMatch[1] === '1') {
                        cssClass = 'conclusion';
                        icon = '✓';
                    }
                }
                
                // 키워드 기반 분류 및 아이콘 설정 (개선된 버전)
                const lowerLine = processedLine.toLowerCase();
                
                // 정상/성공 상태
                if (lowerLine.includes('정상') || lowerLine.includes('normal') || 
                    lowerLine.includes('성공') || lowerLine.includes('완료') || 
                    lowerLine.includes('양호') || lowerLine.includes('success')) {
                    cssClass = 'conclusion';
                    icon = '✅';
                    
                // 오류/문제 상태  
                } else if (lowerLine.includes('이상') || lowerLine.includes('abnormal') || 
                          lowerLine.includes('문제') || lowerLine.includes('오류') || 
                          lowerLine.includes('error') || lowerLine.includes('fault') ||
                          lowerLine.includes('실패') || lowerLine.includes('고장')) {
                    cssClass = 'error';
                    icon = '🚨';
                    
                // 경고/주의 상태
                } else if (lowerLine.includes('주의') || lowerLine.includes('warning') || 
                          lowerLine.includes('확인') || lowerLine.includes('점검') ||
                          lowerLine.includes('권장') || lowerLine.includes('recommend') ||
                          lowerLine.includes('알림') || lowerLine.includes('notice')) {
                    cssClass = 'warning';
                    icon = '⚠️';
                    
                // 온도 관련
                } else if (lowerLine.includes('온도') || lowerLine.includes('temperature') ||
                          lowerLine.includes('℃') || lowerLine.includes('°c') ||
                          lowerLine.includes('열') || lowerLine.includes('냉각')) {
                    cssClass = 'info';
                    icon = '🌡️';
                    
                // 전력/에너지 관련
                } else if (lowerLine.includes('전력') || lowerLine.includes('power') ||
                          lowerLine.includes('에너지') || lowerLine.includes('energy') ||
                          lowerLine.includes('kw') || lowerLine.includes('전기')) {
                    cssClass = 'info';
                    icon = '⚡';
                    
                // 시간/주기 관련
                } else if (lowerLine.includes('시간') || lowerLine.includes('time') ||
                          lowerLine.includes('주기') || lowerLine.includes('cycle') ||
                          lowerLine.includes('분') || lowerLine.includes('초')) {
                    cssClass = 'info';
                    icon = '⏰';
                    
                // 데이터/정보 관련
                } else if (lowerLine.includes('데이터') || lowerLine.includes('정보') || 
                          lowerLine.includes('측정') || lowerLine.includes('기록') ||
                          lowerLine.includes('data') || lowerLine.includes('info') ||
                          lowerLine.includes('로그') || lowerLine.includes('기록')) {
                    cssClass = 'info';
                    icon = '📊';
                    
                // 부족/없음 상태
                } else if (lowerLine.includes('부족') || lowerLine.includes('없음') ||
                          lowerLine.includes('insufficient') || lowerLine.includes('lack') ||
                          lowerLine.includes('missing') || lowerLine.includes('부재')) {
                    cssClass = 'warning';
                    icon = '📉';
                    
                // 기본 아이콘 (첫 번째 항목인 경우 특별 처리)
                } else if (numberedMatch && numberedMatch[1] === '1') {
                    cssClass = 'conclusion';
                    icon = '🏁';
                }
                
                // 텍스트 강조 처리
                processedLine = processTextFormatting(processedLine);
                
                result += `
                    <li class="op-history-item ${cssClass}">
                        <span class="op-history-icon">${icon}</span>
                        <span class="op-history-text">${processedLine}</span>
                    </li>
                `;
            });
            
            result += `
                    </ul>
                </div>
            `;
            
            return result;
        }

        // 텍스트 포맷팅 처리 (강조, 수치 등) - 개선된 버전
        function processTextFormatting(text) {
            let processed = escapeHtml(text);
            
            // 강조 텍스트 처리 (마크다운 스타일)
            processed = processed.replace(/\*\*(.+?)\*\*/g, '<strong style="color: #2c3e50;">$1</strong>');
            processed = processed.replace(/\*(.+?)\*/g, '<em style="color: #6c757d; background: #f8f9fa; padding: 2px 4px; border-radius: 3px;">$1</em>');
            
            // 수치와 단위 하이라이트 (더 포괄적)
            processed = processed.replace(/(\d+(?:\.\d+)?)\s*(℃|°C|도|시간|분|초|%|Hz|rpm|kW|W|A|V|bar|Pa|L\/min|m³\/h|dB)/gi, 
                '<strong style="color: #007bff; background: #e7f3ff; padding: 1px 4px; border-radius: 3px;">$1$2</strong>');
            
            // 날짜와 시간 강조
            processed = processed.replace(/(\d{4}-\d{2}-\d{2}|\d{2}:\d{2}(?::\d{2})?)/g, 
                '<em style="color: #17a2b8; background: #d1ecf1; padding: 1px 4px; border-radius: 3px;">$1</em>');
            
            // 상태 키워드 강조 (더 다양한 키워드)
            processed = processed.replace(/(정상|이상|경고|오류|문제|성공|실패|완료|진행중|대기|Normal|Abnormal|Warning|Error|Success|Failed|Complete|Progress|Pending)/gi, 
                function(match) {
                    const lower = match.toLowerCase();
                    let color = '#2c3e50';
                    let bgColor = '#f8f9fa';
                    
                    if (lower.includes('정상') || lower.includes('normal') || lower.includes('성공') || lower.includes('success') || lower.includes('완료') || lower.includes('complete')) {
                        color = '#28a745';
                        bgColor = '#d4edda';
                    } else if (lower.includes('이상') || lower.includes('abnormal') || lower.includes('오류') || lower.includes('error') || lower.includes('실패') || lower.includes('failed') || lower.includes('문제')) {
                        color = '#dc3545';
                        bgColor = '#f8d7da';
                    } else if (lower.includes('경고') || lower.includes('warning') || lower.includes('주의')) {
                        color = '#fd7e14';
                        bgColor = '#fff3cd';
                    }
                    
                    return `<strong style="color: ${color}; background: ${bgColor}; padding: 2px 6px; border-radius: 4px; font-weight: 600;">${match}</strong>`;
                });
            
            // 퍼센테이지 강조
            processed = processed.replace(/(\d+(?:\.\d+)?%)/g, 
                '<strong style="color: #6f42c1; background: #e7e3ff; padding: 1px 4px; border-radius: 3px;">$1</strong>');
            
            // 범위 표현 강조 (예: 20-25℃, 1-5분)
            processed = processed.replace(/(\d+(?:\.\d+)?)\s*[-~]\s*(\d+(?:\.\d+)?)\s*([℃°CFmin초분시간])/gi,
                '<strong style="color: #20c997; background: #d1f2eb; padding: 1px 4px; border-radius: 3px;">$1-$2$3</strong>');
            
            return processed;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // 포맷팅 적용 함수
        function applyOperationHistoryFormatting(textarea) {
            const rawText = textarea.value;
            if (!rawText || rawText.trim() === '') return;
            
            const parent = textarea.parentNode;
            
            // 기존 포맷된 요소들 제거
            const existingFormatted = parent.querySelector('.formatted-op-history');
            const existingToggle = parent.querySelector('.format-toggle-btn');
            if (existingFormatted) existingFormatted.remove();
            if (existingToggle) existingToggle.remove();
            
            // 포맷된 div 생성
            const formattedDiv = document.createElement('div');
            formattedDiv.innerHTML = formatOperationHistorySummary(rawText);
            
            // 토글 버튼 생성
            const toggleButton = document.createElement('button');
            toggleButton.className = 'format-toggle-btn';
            toggleButton.textContent = '원본';
            toggleButton.title = '원본 텍스트 보기/숨기기';
            
            // textarea 숨기고 포맷된 div와 버튼 추가
            textarea.style.display = 'none';
            parent.appendChild(formattedDiv);
            parent.appendChild(toggleButton);
            
            // 토글 기능
            let showingFormatted = true;
            function toggleDisplay() {
                if (showingFormatted) {
                    // 원본 텍스트 표시
                    textarea.style.display = 'block';
                    formattedDiv.style.display = 'none';
                    toggleButton.textContent = '포맷';
                    toggleButton.title = '포맷된 보기로 전환';
                    showingFormatted = false;
                } else {
                    // 포맷된 텍스트 표시
                    textarea.style.display = 'none';
                    formattedDiv.style.display = 'block';
                    toggleButton.textContent = '원본';
                    toggleButton.title = '원본 텍스트 보기로 전환';
                    showingFormatted = true;
                }
            }
            
            // 이벤트 리스너 추가
            toggleButton.addEventListener('click', toggleDisplay);
            formattedDiv.addEventListener('dblclick', toggleDisplay);
            
            // 포맷된 div에 툴팁 추가
            const formattedContent = formattedDiv.querySelector('.formatted-op-history');
            if (formattedContent) {
                formattedContent.title = '더블클릭하면 원본 텍스트를 볼 수 있습니다';
            }
        }

        // 스트리밍 콘텐츠 생성
        async function generateContent() {
            const selectedId = document.getElementById('idSelect').value;
            const selectedLlm = document.getElementById('llmSelect').value;
            const selectedLanguage = document.getElementById('languageSelect').value;
            
            const diagnosisSummarizationTextarea = document.getElementById('diagnosisSummarization');
            const opHistorySummarizationTextarea = document.getElementById('opHistorySummarization');
            const diagnosisListsTextarea = document.getElementById('diagnosisLists');
            const operationHistoryTextarea = document.getElementById('operationHistory');
            
            if (!selectedId) {
                alert('ID를 선택해주세요.');
                return;
            }

            // 로딩 상태 표시
            const generateBtn = document.getElementById('generateBtn');
            const spinner = document.getElementById('loadingSpinner');
            const statusMessage = document.getElementById('statusMessage');
            
            generateBtn.disabled = true;
            spinner.style.display = 'block';
            statusMessage.classList.remove('active'); // 상태 메시지 초기화
            
            // 텍스트 영역 초기화 및 기존 포맷 제거
            diagnosisSummarizationTextarea.value = '';
            opHistorySummarizationTextarea.value = '';
            document.getElementById('userGuide').value = ''; // User Guide 초기화
            
            // 기존 포맷된 디스플레이 제거 - 더 철저한 정리
            [diagnosisSummarizationTextarea, opHistorySummarizationTextarea, document.getElementById('userGuide')].forEach(textarea => {
                resetTextboxGroup(textarea);
            });

            try {
                // 먼저 원본 데이터 로드 (JSON 형태로 표시)
                await loadOriginalData(selectedId, diagnosisListsTextarea, operationHistoryTextarea);
                
                // 병렬로 두 개의 스트리밍 요청 시작
                const diagnosisPromise = streamDiagnosis(selectedId, selectedLlm, selectedLanguage, diagnosisSummarizationTextarea);
                const opHistoryPromise = streamOperationHistory(selectedId, selectedLlm, selectedLanguage, opHistorySummarizationTextarea);
                
                // 두 스트리밍이 모두 완료될 때까지 대기
                await Promise.all([diagnosisPromise, opHistoryPromise]);
                
                // 스트리밍 완료 후 포맷팅 적용 (진단과 운영 이력 모두)
                setTimeout(() => {
                    applyDiagnosisFormatting(diagnosisSummarizationTextarea);
                    applyOperationHistoryFormatting(opHistorySummarizationTextarea);
                    // 진단 결과가 '자가 조치 가능'인 경우 고객 조치 가이드 생성 (한국어일 때만)
                    tryGenerateActionsGuide();
                }, 500); // 약간의 지연 후 포맷팅 적용

            } catch (error) {
                console.error('Error during content generation:', error);
                diagnosisSummarizationTextarea.value = `Error: ${error.message}`;
                opHistorySummarizationTextarea.value = `Error: ${error.message}`;
            } finally {
                // 로딩 상태 해제
                generateBtn.disabled = false;
                spinner.style.display = 'none';
                statusMessage.classList.remove('active'); // 상태 메시지 숨기기
            }
        }

        function extractConclusionKo(text) {
            // 결론: 자가 조치 가능/수리 필요/정상 등 패턴 탐지
            const m = text.match(/결론\s*[:：]\s*([^\n]+)/);
            return m ? m[1].trim() : '';
        }

        function tryGenerateActionsGuide() {
            const lang = document.getElementById('languageSelect').value;
            if (lang !== 'ko') {
                console.log('[tryGenerateActionsGuide] 언어가 한국어가 아님:', lang);
                return;
            }
            
            const diagnosisText = document.getElementById('diagnosisSummarization').value || '';
            console.log('[tryGenerateActionsGuide] 진단 텍스트:', diagnosisText.substring(0, 200) + '...');
            
            const conclusion = extractConclusionKo(diagnosisText);
            console.log('[tryGenerateActionsGuide] 추출된 결론:', conclusion);
            
            if (!conclusion || !/자가\s*조치\s*가능|자가\s*해결\s*가능/.test(conclusion)) {
                console.log('[tryGenerateActionsGuide] 결론이 자가 조치 가능이 아님:', conclusion);
                return;
            }

            const selectedProduct = document.getElementById('productSelect').value; // airconditioner|refrigerator|washer
            const selectedId = document.getElementById('idSelect').value;
            
            console.log('[tryGenerateActionsGuide] 시작:', {
                lang,
                conclusion,
                selectedProduct,
                selectedId
            });

            // User Guide 생성 상태 메시지 표시
            const statusMessage = document.getElementById('statusMessage');
            statusMessage.textContent = '"User Guide"를 생성 중입니다.';
            statusMessage.classList.add('active');

            const userGuideTextarea = document.getElementById('userGuide');
            userGuideTextarea.value = '';

            // 진단 요약에서 가독성 보고서 부분 제거 (원본 내용만 전송)
            const cleanDiagnosisText = diagnosisText.split('📊 **가독성 분석 결과**')[0].trim();

            // 서버에 가이드 생성을 요청 (SSE streaming) - POST로 변경하여 진단 요약 전송
            const url = `/api/stream/actions-guide/${selectedId}`;
            
            console.log('[tryGenerateActionsGuide] API 요청:', {
                url,
                category: selectedProduct,
                language: lang,
                diagnosis_summary_length: cleanDiagnosisText.length
            });
            
            fetch(url, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    category: selectedProduct,
                    language: lang,
                    diagnosis_summary: cleanDiagnosisText
                })
            }).then(resp => {
                if (!resp.ok) throw new Error(`HTTP error ${resp.status}`);
                console.log('[tryGenerateActionsGuide] 응답 받음, 스트림 시작');
                const reader = resp.body.getReader();
                const decoder = new TextDecoder();
                function readStream() {
                    reader.read().then(({done, value}) => {
                        if (done) {
                            console.log('[tryGenerateActionsGuide] 스트림 완료');
                            return;
                        }
                        const chunk = decoder.decode(value);
                        const lines = chunk.split('\n');
                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                try {
                                    const data = JSON.parse(line.slice(6));
                                    if (data.error) {
                                        console.error('[tryGenerateActionsGuide] 서버 에러:', data.error);
                                        statusMessage.classList.remove('active'); // 에러 시 상태 메시지 숨기기
                                        userGuideTextarea.value = `오류: ${data.error}`;
                                        return;
                                    }
                                    if (data.chunk) {
                                        userGuideTextarea.value += data.chunk;
                                        console.log('[tryGenerateActionsGuide] 청크 받음:', data.chunk.substring(0, 50) + '...');
                                    }
                                    if (data.done) {
                                        console.log('[tryGenerateActionsGuide] 스트림 완료, 후처리 시작');
                                        // User Guide 생성 완료 - 상태 메시지 숨기기
                                        statusMessage.classList.remove('active');
                                        // 스트림 완료 후 가독성 보고서 처리 및 포맷팅
                                        setTimeout(() => {
                                            processReadabilityReport(userGuideTextarea);
                                            applyUserGuideFormatting(userGuideTextarea);
                                        }, 200);
                                        return;
                                    }
                                } catch (e) {
                                    console.warn('[tryGenerateActionsGuide] JSON 파싱 오류:', e, line);
                                }
                            }
                        }
                        readStream();
                    }).catch((e) => {
                        console.error('[tryGenerateActionsGuide] 스트림 읽기 오류:', e);
                        statusMessage.classList.remove('active'); // 스트림 오류 시 상태 메시지 숨기기
                    });
                }
                readStream();
            }).catch((e) => {
                console.error('[tryGenerateActionsGuide] fetch 오류:', e);
                statusMessage.classList.remove('active'); // fetch 오류 시 상태 메시지 숨기기
                userGuideTextarea.value = `요청 오류: ${e.message}`;
            });
        }

        // User Guide 포맷팅
        function formatUserGuide(rawText) {
            if (!rawText || rawText.trim() === '') return '';
            const lines = rawText.split('\n').filter(l => l.trim() !== '');
            const items = [];
            for (let i = 0; i < lines.length; i++) {
                const m = lines[i].match(/^(\d+)\.\s*(.+)$/);
                if (m) {
                    let content = m[2];
                    // 다음 줄이 번호가 아니면 같은 항목으로 이어붙임
                    let j = i + 1;
                    while (j < lines.length && !/^(\d+)\./.test(lines[j])) {
                        content += ' ' + lines[j].trim();
                        j++;
                    }
                    i = j - 1;
                    // 출처 URL 추출
                    let sourceHtml = '';
                    const urlMatch = content.match(/출처\s*:\s*(https?:\/\/\S+)/i);
                    if (urlMatch) {
                        const url = urlMatch[1];
                        content = content.replace(urlMatch[0], '').trim();
                        sourceHtml = ` <span class="user-guide-source">(출처: <a href="${url}" target="_blank">${url}</a>)</span>`;
                    }
                    // 강조 처리
                    content = processTextFormatting(content);
                    items.push(`<li class="user-guide-item">${content}${sourceHtml}</li>`);
                }
            }
            let html = `
                <div class="formatted-user-guide">
                    <h3 class="user-guide-title">
                        <span>고객 조치 가이드</span>
                    </h3>
                    <ol class="user-guide-list">${items.join('')}</ol>
                </div>
            `;
            return html;
        }

        function applyUserGuideFormatting(textarea) {
            const rawText = textarea.value;
            if (!rawText || rawText.trim() === '') return;
            const parent = textarea.parentNode;
            const existing = parent.querySelector('.formatted-user-guide');
            const existingToggle = parent.querySelector('.format-toggle-btn');
            if (existing) existing.remove();
            if (existingToggle) existingToggle.remove();

            const formattedDiv = document.createElement('div');
            formattedDiv.innerHTML = formatUserGuide(rawText);

            const toggleButton = document.createElement('button');
            toggleButton.className = 'format-toggle-btn';
            toggleButton.textContent = '원본';
            toggleButton.title = '원본 텍스트 보기/숨기기';
            
            // 가독성 섹션이 있는지 확인
            const readabilitySection = parent.querySelector('.readability-section');
            
            // textarea 숨기고 포맷된 div와 버튼 추가
            textarea.style.display = 'none';
            
            // 가독성 섹션이 있으면 그 앞에 추가, 없으면 맨 뒤에 추가
            if (readabilitySection) {
                parent.insertBefore(formattedDiv, readabilitySection);
                parent.insertBefore(toggleButton, readabilitySection);
            } else {
                parent.appendChild(formattedDiv);
                parent.appendChild(toggleButton);
            }

            let showingFormatted = true;
            function toggleDisplay() {
                if (showingFormatted) {
                    textarea.style.display = 'block';
                    formattedDiv.style.display = 'none';
                    toggleButton.textContent = '포맷';
                    toggleButton.title = '포맷된 보기로 전환';
                    showingFormatted = false;
                } else {
                    textarea.style.display = 'none';
                    formattedDiv.style.display = 'block';
                    toggleButton.textContent = '원본';
                    toggleButton.title = '원본 텍스트 보기로 전환';
                    showingFormatted = true;
                }
            }

            toggleButton.addEventListener('click', toggleDisplay);
            formattedDiv.addEventListener('dblclick', toggleDisplay);
        }

        // 원본 데이터 로드 (기존 기능 유지)
        async function loadOriginalData(selectedId, diagnosisTextarea, operationTextarea) {
            try {
                // 진단 데이터 가져오기
                const diagnosisResponse = await fetch(`/api/diagnosis/${selectedId}`);
                if (diagnosisResponse.ok) {
                    const diagnosisData = await diagnosisResponse.json();
                    diagnosisTextarea.value = JSON.stringify(diagnosisData, null, 2);
                } else {
                    diagnosisTextarea.value = 'No diagnosis data available for this item.';
                }

                // 운영 이력 데이터 가져오기
                const operationResponse = await fetch(`/api/operation-history/${selectedId}`);
                if (operationResponse.ok) {
                    const contentType = operationResponse.headers.get('content-type');
                    if (contentType && contentType.includes('application/json')) {
                        // 일반 JSON 응답 (짧은 데이터)
                        const operationData = await operationResponse.json();
                        operationTextarea.value = JSON.stringify(operationData, null, 2);
                    } else {
                        // 잘린 텍스트 응답 (긴 데이터)
                        const operationText = await operationResponse.text();
                        operationTextarea.value = operationText;
                    }
                } else {
                    operationTextarea.value = 'No operation history data available for this item.';
                }
            } catch (error) {
                diagnosisTextarea.value = `Error loading data: ${error.message}`;
                operationTextarea.value = `Error loading data: ${error.message}`;
            }
        }

        // 진단 스트리밍
        async function streamDiagnosis(itemId, llm, language, textarea) {
            return new Promise((resolve, reject) => {
                const url = `/api/stream/diagnosis/${itemId}?llm=${llm}&language=${language}`;
                
                fetch(url)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        
                        function readStream() {
                            reader.read().then(({ done, value }) => {
                                if (done) {
                                    // 스트리밍 완료 후 가독성 보고서 처리
                                    processReadabilityReport(textarea);
                                    resolve();
                                    return;
                                }
                                
                                const chunk = decoder.decode(value);
                                const lines = chunk.split('\n');
                                
                                for (const line of lines) {
                                    if (line.startsWith('data: ')) {
                                        try {
                                            const data = JSON.parse(line.slice(6));
                                            if (data.error) {
                                                textarea.value += `Error: ${data.error}`;
                                                reject(new Error(data.error));
                                                return;
                                            }
                                            if (data.chunk) {
                                                textarea.value += data.chunk;
                                            }
                                            if (data.done) {
                                                // 스트리밍 완료 후 가독성 보고서 처리
                                                processReadabilityReport(textarea);
                                                resolve();
                                                return;
                                            }
                                        } catch (e) {
                                            // JSON 파싱 오류 무시 (불완전한 데이터)
                                        }
                                    }
                                }
                                
                                readStream();
                            }).catch(reject);
                        }
                        
                        readStream();
                    })
                    .catch(reject);
            });
        }

        // 운영 이력 스트리밍
        async function streamOperationHistory(itemId, llm, language, textarea) {
            return new Promise((resolve, reject) => {
                const url = `/api/stream/operation-history/${itemId}?llm=${llm}&language=${language}`;
                
                fetch(url)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        
                        function readStream() {
                            reader.read().then(({ done, value }) => {
                                if (done) {
                                    // 스트리밍 완료 후 가독성 보고서 처리
                                    processReadabilityReport(textarea);
                                    resolve();
                                    return;
                                }
                                
                                const chunk = decoder.decode(value);
                                const lines = chunk.split('\n');
                                
                                for (const line of lines) {
                                    if (line.startsWith('data: ')) {
                                        try {
                                            const data = JSON.parse(line.slice(6));
                                            if (data.error) {
                                                textarea.value += `Error: ${data.error}`;
                                                reject(new Error(data.error));
                                                return;
                                            }
                                            if (data.chunk) {
                                                textarea.value += data.chunk;
                                            }
                                            if (data.done) {
                                                // 스트리밍 완료 후 가독성 보고서 처리
                                                processReadabilityReport(textarea);
                                                resolve();
                                                return;
                                            }
                                        } catch (e) {
                                            // JSON 파싱 오류 무시 (불완전한 데이터)
                                        }
                                    }
                                }
                                
                                readStream();
                            }).catch(reject);
                        }
                        
                        readStream();
                    })
                    .catch(reject);
            });
        }

        // 가독성 보고서 처리 함수
        function processReadabilityReport(textarea) {
            const content = textarea.value;
            
            // 가독성 분석 결과 섹션 찾기
            const reportStartIndex = content.indexOf('📊 **가독성 분석 결과**');
            if (reportStartIndex === -1) {
                return; // 가독성 보고서가 없으면 처리하지 않음
            }
            
            // 원본 내용과 가독성 보고서 분리
            const originalContent = content.substring(0, reportStartIndex).trim();
            const reportContent = content.substring(reportStartIndex).trim();
            
            // 가독성 보고서 파싱
            const readabilityData = parseReadabilityReport(reportContent);
            
            // 원본 내용만 textarea에 유지
            textarea.value = originalContent;
            
            // 가독성 섹션 생성 및 표시
            createReadabilitySection(textarea, readabilityData);
        }

        function parseReadabilityReport(reportText) {
            const data = {
                overall: 'unknown',
                metrics: {},
                technicalTerms: [],
                recommendations: []
            };
            
            try {
                // 종합 평가 파싱
                const overallMatch = reportText.match(/🎯 \*\*종합 평가\*\*: (✅|❌) (양호|개선 필요)/);
                if (overallMatch) {
                    data.overall = overallMatch[2] === '양호' ? 'good' : 'poor';
                }
                
                // 세부 분석 파싱
                const metricsSection = reportText.match(/📋 \*\*세부 분석\*\*:([\s\S]*?)(?=🔍|\💡|$)/);
                if (metricsSection) {
                    const metricsText = metricsSection[1];
                    
                    // 개조식 형태
                    const bulletMatch = metricsText.match(/• 개조식 형태: (✅|❌) (\d+)개 항목 \((양호|개선 필요)\)/);
                    if (bulletMatch) {
                        data.metrics.bullet = {
                            icon: bulletMatch[1],
                            count: parseInt(bulletMatch[2]),
                            status: bulletMatch[3]
                        };
                    }
                    
                    // 단어 수
                    const wordMatch = metricsText.match(/• 단어 수: (✅|❌) (\d+)개 단어 \((양호|개선 필요)\)/);
                    if (wordMatch) {
                        data.metrics.words = {
                            icon: wordMatch[1],
                            count: parseInt(wordMatch[2]),
                            status: wordMatch[3]
                        };
                    }
                    
                    // 용어 난이도
                    const termsMatch = metricsText.match(/• 용어 난이도: (✅|❌) 전문용어 ([\d.]+)% \((양호|개선 필요)\)/);
                    if (termsMatch) {
                        data.metrics.terms = {
                            icon: termsMatch[1],
                            ratio: parseFloat(termsMatch[2]),
                            status: termsMatch[3]
                        };
                    }
                    
                    // 가독성 점수
                    const scoreMatch = metricsText.match(/• 가독성 점수: (✅|❌) FK (\d+)점 \((양호|개선 필요)\)/);
                    if (scoreMatch) {
                        data.metrics.score = {
                            icon: scoreMatch[1],
                            value: parseInt(scoreMatch[2]),
                            status: scoreMatch[3]
                        };
                    }
                }
                
                // 발견된 전문용어 파싱
                const termsMatch = reportText.match(/🔍 \*\*발견된 전문용어\*\*: (.+)/);
                if (termsMatch) {
                    data.technicalTerms = termsMatch[1].split(', ').map(term => term.trim());
                }
                
                // 개선 권장사항 파싱
                const recommendationsMatch = reportText.match(/💡 \*\*개선 권장사항\*\*:([\s\S]*?)$/);
                if (recommendationsMatch) {
                    const recommendationsText = recommendationsMatch[1];
                    const recommendations = recommendationsText.match(/• ([^\n]+)/g);
                    if (recommendations) {
                        data.recommendations = recommendations.map(rec => rec.replace('• ', '').trim());
                    }
                }
                
            } catch (error) {
                console.error('가독성 보고서 파싱 오류:', error);
            }
            
            return data;
        }

        function createReadabilitySection(textarea, data) {
            const parent = textarea.parentNode; // textbox-group
            
            // 기존 가독성 섹션 제거
            const existingSection = parent.querySelector('.readability-section');
            if (existingSection) {
                existingSection.remove();
            }
            
            // 새 가독성 섹션 생성
            const section = document.createElement('div');
            section.className = 'readability-section';
            // CSS에서 이미 margin-top: 20px가 정의되어 있으므로 inline style 제거
            
            const overallClass = data.overall === 'good' ? 'good' : 'poor';
            const overallText = data.overall === 'good' ? '양호' : '개선 필요';
            const overallIcon = data.overall === 'good' ? '✅' : '❌';
            
            let metricsHtml = '';
            if (data.metrics.bullet) {
                metricsHtml += `
                    <div class="readability-metric">
                        <span class="icon">${data.metrics.bullet.icon}</span>
                        <span>개조식 ${data.metrics.bullet.count}개 항목</span>
                    </div>
                `;
            }
            if (data.metrics.words) {
                metricsHtml += `
                    <div class="readability-metric">
                        <span class="icon">${data.metrics.words.icon}</span>
                        <span>${data.metrics.words.count}개 단어</span>
                    </div>
                `;
            }
            if (data.metrics.terms) {
                metricsHtml += `
                    <div class="readability-metric">
                        <span class="icon">${data.metrics.terms.icon}</span>
                        <span>전문용어 ${data.metrics.terms.ratio}%</span>
                    </div>
                `;
            }
            if (data.metrics.score) {
                metricsHtml += `
                    <div class="readability-metric">
                        <span class="icon">${data.metrics.score.icon}</span>
                        <span>가독성 ${data.metrics.score.value}점</span>
                    </div>
                `;
            }
            
            let technicalTermsHtml = '';
            if (data.technicalTerms.length > 0) {
                technicalTermsHtml = `
                    <div class="readability-terms">
                        <div class="readability-terms-title">🔍 발견된 전문용어</div>
                        <div class="readability-terms-list">${data.technicalTerms.join(', ')}</div>
                    </div>
                `;
            }
            
            let recommendationsHtml = '';
            if (data.recommendations.length > 0) {
                const recommendationsList = data.recommendations.map(rec => `<li>${rec}</li>`).join('');
                recommendationsHtml = `
                    <div class="readability-recommendations">
                        <div class="readability-recommendations-title">
                            <span>💡</span>
                            <span>개선 권장사항</span>
                        </div>
                        <ul>${recommendationsList}</ul>
                    </div>
                `;
            }
            
            section.innerHTML = `
                <div class="readability-header">
                    <div class="readability-title">
                        <span>📊</span>
                        <span>가독성 분석 결과</span>
                    </div>
                    <button class="readability-toggle" onclick="toggleReadabilitySection(this)">접기</button>
                </div>
                <div class="readability-content">
                    <div class="readability-overall ${overallClass}">
                        <span>${overallIcon}</span>
                        <span>종합 평가: ${overallText}</span>
                    </div>
                    <div class="readability-metrics">
                        ${metricsHtml}
                    </div>
                    ${technicalTermsHtml}
                    ${recommendationsHtml}
                </div>
            `;
            
            // textbox-group의 맨 마지막에 가독성 섹션 추가 (textarea 아래)
            parent.appendChild(section);
        }

        function toggleReadabilitySection(button) {
            const content = button.closest('.readability-section').querySelector('.readability-content');
            const isCollapsed = content.classList.contains('readability-collapsed');
            
            if (isCollapsed) {
                content.classList.remove('readability-collapsed');
                button.textContent = '접기';
            } else {
                content.classList.add('readability-collapsed');
                button.textContent = '펼치기';
            }
        }

        // Textbox group을 원래 상태로 완전히 리셋하는 함수
        function resetTextboxGroup(textarea) {
            const parent = textarea.parentNode;
            
            // 모든 동적으로 추가된 요소들 제거
            const dynamicElements = parent.querySelectorAll('.formatted-op-history, .formatted-diagnosis, .formatted-user-guide, .format-toggle-btn, .readability-section');
            dynamicElements.forEach(element => element.remove());
            
            // textarea를 다시 표시하고 스타일 초기화
            textarea.style.display = 'block';
            textarea.style.position = '';
            textarea.style.margin = '';
            textarea.style.padding = '';
            
            // 부모 컨테이너의 스타일도 초기화
            parent.style.height = '';
            parent.style.minHeight = '';
        }

        // 페이지 로드 시 JSON 데이터 로드
        window.addEventListener('load', loadJsonData);
    </script>
</body>
</html>
